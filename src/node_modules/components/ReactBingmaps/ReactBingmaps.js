import React, { Component } from 'react';
import classSet from 'classnames';
import PropTypes from 'prop-types';
import './ReactBingmaps.css';
var Microsoft;
class ReactBingmaps extends Component {
	constructor(props) {
		super(props);
		this.initializeReactBingmaps=this.initializeReactBingmaps.bind(this);	
	}
	componentDidMount(){	
		window.initializeReactBingmaps = function(){	
			Microsoft = window.Microsoft;		
			this.initializeReactBingmaps(this.props)
		}.bind(this)
		this.loadScript("https://www.bing.com/api/maps/mapcontrol?callback=initializeReactBingmaps");
	}
	MakeCallback(callback){
		callback();
	}
	initializeReactBingmaps(props){	
		const { 
			bingmapKey, 
			center, 
			mapTypeId,
			zoom,
			navigationBarMode,
			supportedMapTypes,
			heading,
			pushPins,
			disableStreetside,
			infoboxes,
			infoboxesWithPushPins
		} = props;
		let isBirdEyeAvailable = false;
		if(mapTypeId === "birdseye" && center && center[0] && center[1]){
			let location = new Microsoft.Maps.Location(center[0], center[1]);
			Microsoft.Maps.getIsBirdseyeAvailable(location, Microsoft.Maps.Heading[heading], (onResponse => { isBirdEyeAvailable = onResponse; }));
		}
		if(bingmapKey){
			var map = new Microsoft.Maps.Map('.react-bingmaps', {
				credentials: bingmapKey,
				...((center && center[0] && center[1]) ? {center: new Microsoft.Maps.Location(center[0], center[1])} : {}),
	            ...((mapTypeId) ? {mapTypeId: isBirdEyeAvailable ? Microsoft.Maps.MapTypeId.birdseye : Microsoft.Maps.MapTypeId[mapTypeId]} : {}),
	            ...((zoom) ? {zoom: zoom} : {}),
	            ...((navigationBarMode) ? {navigationBarMode: Microsoft.Maps.NavigationBarMode[navigationBarMode]} : {}),
	            ...((supportedMapTypes) ? {supportedMapTypes: supportedMapTypes.map((id) => Microsoft.Maps.MapTypeId[id])} : {}),
	            ...((disableStreetside) ? {disableStreetside: disableStreetside} : {disableStreetside:disableStreetside} )
			});
			if(pushPins){
				for(var pushPinIndex = 0; pushPinIndex < pushPins.length; pushPinIndex++){
					if(pushPins[pushPinIndex].location && pushPins[pushPinIndex].location[0] && pushPins[pushPinIndex].location[1]) {
						let location =  new Microsoft.Maps.Location(pushPins[pushPinIndex].location[0], pushPins[pushPinIndex].location[1]);
						let option = pushPins[pushPinIndex] ? pushPins[pushPinIndex].option : null
						if(option.anchor && option.anchor[0] && option.anchor[1]){
							option.anchor = new Microsoft.Maps.Point(option.anchor[0], option.anchor[1])
						}
						let pushpin = new Microsoft.Maps.Pushpin(location, option);
						map.entities.push(pushpin);
						if(pushPins[pushPinIndex].addHandler){
							Microsoft.Maps.Events.addHandler(pushpin, pushPins[pushPinIndex].addHandler.type, 
								function (callback) { this.MakeCallback(callback) }.bind(this, pushPins[pushPinIndex].addHandler.callback));
						}
					}
				}
			}
			if(infoboxes){
				for(var infoboxIndex = 0; infoboxIndex < infoboxes.length; infoboxIndex++){
					if(infoboxes[infoboxIndex].location && infoboxes[infoboxIndex].location[0] && infoboxes[infoboxIndex].location[1]) {
						let location =  new Microsoft.Maps.Location(infoboxes[infoboxIndex].location[0], infoboxes[infoboxIndex].location[1]);
						let option = infoboxes[infoboxIndex] ? infoboxes[infoboxIndex].option : null
						let infobox = new Microsoft.Maps.Infobox(location, option);
						infobox.setMap(map);
						if(infoboxes[infoboxIndex].addHandler){
							Microsoft.Maps.Events.addHandler(infobox, infoboxes[infoboxIndex].addHandler.type, 
								function (callback) { this.MakeCallback(callback) }.bind(this, infoboxes[infoboxIndex].addHandler.callback));
						}
					}
				}
			}
			if(infoboxesWithPushPins){
				for(var infoboxWithPushPinIndex = 0; infoboxWithPushPinIndex < infoboxesWithPushPins.length; infoboxWithPushPinIndex++){
					if(infoboxesWithPushPins[infoboxWithPushPinIndex].location){
						let location =  new Microsoft.Maps.Location(infoboxesWithPushPins[infoboxWithPushPinIndex].location[0], infoboxesWithPushPins[infoboxWithPushPinIndex].location[1]);
						let infoboxOption = infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxOption ? infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxOption : null
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler){
							infoboxOption["visible"] = false;
						}
						let pushPinOption = infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinOption ? infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinOption : null
						if(pushPinOption.anchor && pushPinOption.anchor[0] && pushPinOption.anchor[1]){
							pushPinOption.anchor = new Microsoft.Maps.Point(pushPinOption.anchor[0], pushPinOption.anchor[1])
						}
						let infobox = new Microsoft.Maps.Infobox(location, infoboxOption);
						infobox.setMap(map);
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler){
							Microsoft.Maps.Events.addHandler(infobox, infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.type, 
								function (callback) { this.MakeCallback(callback) }.bind(this, infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.callback));
						}						
						let pushpin = new Microsoft.Maps.Pushpin(location, pushPinOption);
						map.entities.push(pushpin);
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler){
							Microsoft.Maps.Events.addHandler(infobox, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.type, 
								function (callback) { this.MakeCallback(callback) }.bind(this, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.callback));
						}
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler){
							if(infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler === "mouseover"){
								Microsoft.Maps.Events.addHandler(pushpin, infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler, function () {
								    infobox.setOptions({ visible: true });
								});
								Microsoft.Maps.Events.addHandler(pushpin, "mouseout", function () {
								    infobox.setOptions({ visible: false });
								});
							}
						}
					}
				}
			}
		}
	}
	loadScript(url){
	    var script = document.createElement("script")
	    script.type = "text/javascript";
	    script.async = true;
	    script.defer = true;	    
	    script.src = url;
	    document.getElementsByTagName("head")[0].appendChild(script);
	}
	componentWillReceiveProps(nextProps){
		this.initializeReactBingmaps(nextProps);
	}
	componentDidUpdate(){

	}
	componentWillUnmount() {
		
	}
	render() {
		return(
				<div className = { classSet('react-bingmaps', this.props.className) }>
				</div>
			);
	}
}

export default ReactBingmaps;

ReactBingmaps.propTypes = {
	bingmapKey: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	center: PropTypes.arrayOf(PropTypes.number),
	mapTypeId: PropTypes.string,
	navigationBarMode: PropTypes.string,
	supportedMapTypes: PropTypes.arrayOf(PropTypes.string),
	heading: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	zoom: PropTypes.number,
	pushPins: PropTypes.arrayOf(
		PropTypes.shape({
		    location: PropTypes.arrayOf(PropTypes.number),
		    option: PropTypes.object,
		    addHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    })
		})
	),
	disableStreetside: PropTypes.bool,
	infoboxes: PropTypes.arrayOf(
		PropTypes.shape({
		    location: PropTypes.arrayOf(PropTypes.number),
		    option: PropTypes.object,
		    addHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    })
		})
	),
	infoboxesWithPushPins: PropTypes.arrayOf(
		PropTypes.shape({
			location: PropTypes.arrayOf(PropTypes.number),
			addHandler: PropTypes.string,
			infoboxOption: PropTypes.object,
			pushPinOption: PropTypes.object,
			infoboxAddHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    }),
		    pushPinAddHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    })
		})
	)
}
ReactBingmaps.defaultProps = {
	bingmapKey: undefined,
	center: undefined,
	mapTypeId: undefined,
	navigationBarMode: undefined,
	supportedMapTypes: undefined,
	heading: 0,
	pushPins: undefined,
	disableStreetside: true,
	infoboxes: undefined,
	infoboxesWithPushPins: undefined,
	zoom: undefined
}