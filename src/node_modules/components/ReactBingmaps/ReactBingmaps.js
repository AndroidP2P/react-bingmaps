import React, { Component } from 'react';
import classSet from 'classnames';
import PropTypes from 'prop-types';
import ReactDOMServer from 'react-dom/server';
import './ReactBingmaps.css';

var map, Microsoft, infobox = {};
class ReactBingmaps extends Component {
	// constructor(props) {
	// 	super(props);
	// }
	componentDidMount(){	
		window.bingmapsCallback = function(){	
			Microsoft = window.Microsoft;
			this.reactBingmaps(this.props, Microsoft)
		}.bind(this)

		if(Microsoft === null || Microsoft === undefined){
			this.loadScript("https://www.bing.com/api/maps/mapcontrol?callback=bingmapsCallback");
		}
		else{
			this.reactBingmaps(this.props, Microsoft)			
		}
	}
	componentWillReceiveProps(nextProps){
		if(this.props.center !== nextProps.center){
			this.setMapCenter(nextProps.center);
		}
		if(this.props.zoom !== nextProps.zoom){
			this.setMapZoom(nextProps.zoom);
		}
		if(this.props.mapTypeId !== nextProps.mapTypeId){
			this.setMapTypeId(nextProps.mapTypeId, nextProps.center, nextProps.heading);
		}
		if(this.props.navigationBarMode !== nextProps.navigationBarMode){
			this.setMapNavigationBarMode(nextProps.navigationBarMode);
		}
		if(this.props.supportedMapTypes !== nextProps.supportedMapTypes){
			this.setMapSupportedMapTypes(nextProps.supportedMapTypes);
		}
		if(this.props.disableStreetside !== nextProps.disableStreetside){
			this.setDisableStreetside(nextProps.disableStreetside);
		}
		if(this.props.pushPins !== nextProps.pushPins){
			this.setPushPins(nextProps.pushPins);
		}
		if(this.props.infoboxes !== nextProps.infoboxes){
			this.setInfoboxes(nextProps.infoboxes, "infoboxes");
		}
		if(this.props.infoboxesWithPushPins !== nextProps.infoboxesWithPushPins){
			this.setInfoboxesWithPushPins(nextProps.infoboxesWithPushPins, "infoboxesWithPushPins");
		}
		if(this.props.regularPolygons !== nextProps.regularPolygons){
			this.createRegularPolygons(nextProps.regularPolygons);
		}
	}
	componentWillUnmount(){
		if(map)
			map.dispose();

		map = undefined;
		infobox = {};
	}
	loadScript(url){
	    var script = document.createElement("script")
	    script.type = "text/javascript";
	    script.async = true;
	    script.defer = true;	    
	    script.src = url;
	    document.getElementsByTagName("head")[0].appendChild(script);
	}
	reactBingmaps(props,  Microsoft){
		const { 
			bingmapKey, 
			center, 
			mapTypeId,
			zoom,
			navigationBarMode,
			supportedMapTypes,
			heading,
			pushPins,
			disableStreetside,
			infoboxes,
			infoboxesWithPushPins,
			getLocation,
			regularPolygons
		} = props;
		if(bingmapKey && Microsoft){
			if(!map){
				map = new Microsoft.Maps.Map('.react-bingmaps', {
					credentials: bingmapKey
				});
			}
			this.setMapCenter(center);
			this.setMapTypeId(mapTypeId, center, heading);
			this.setMapZoom(zoom);
			this.setMapNavigationBarMode(navigationBarMode);
			this.setMapSupportedMapTypes(supportedMapTypes);
			this.setDisableStreetside(disableStreetside);
			this.setPushPins(pushPins);
			this.setInfoboxes(infoboxes, "infoboxes");
			this.setInfoboxesWithPushPins(infoboxesWithPushPins, "infoboxesWithPushPins");
			this.setGetLocation(getLocation);
			this.createRegularPolygons(regularPolygons);
		}
	}
	setMapCenter(center){
		if(map && center && center[0] && center[1]){
			map.setView({
	            center: new Microsoft.Maps.Location(center[0], center[1])
	        });
		}
	}
	setMapTypeId(mapTypeId, center, heading){
		if(map && mapTypeId){
			let isBirdEyeAvailable = false;
			if(mapTypeId === "birdseye" && center && center[0] && center[1]){
				let location = new Microsoft.Maps.Location(center[0], center[1]);
				Microsoft.Maps.getIsBirdseyeAvailable(location, Microsoft.Maps.Heading[heading], (onResponse => { isBirdEyeAvailable = onResponse; }));
			}
			if(mapTypeId){
				map.setView({
		            mapTypeId: isBirdEyeAvailable ? Microsoft.Maps.MapTypeId.birdseye : Microsoft.Maps.MapTypeId[mapTypeId]
		        });
			}
		}
	}
	setMapZoom(zoom){
		if(map && zoom){
			map.setView({
	            zoom: zoom
	        });
		}
	}
	setMapNavigationBarMode(navigationBarMode){
		if(map && navigationBarMode){
			map.setView({
	            navigationBarMode: navigationBarMode
	        });
		}
	}
	setMapSupportedMapTypes(supportedMapTypes){
		if(map && supportedMapTypes){
			map.setView({
	            supportedMapTypes: supportedMapTypes.map((id) => Microsoft.Maps.MapTypeId[id])
	        });
		}
	}
	setDisableStreetside(disableStreetside){
		if(map && disableStreetside){
			map.setView({
	            disableStreetside: disableStreetside
	        });
		}
	}
	setPushPins(pushPins){		
		if(map && pushPins){
			for (var i = map.entities.getLength() - 1; i >= 0; i--) {
		        var pushpin = map.entities.get(i);
		        if (pushpin instanceof Microsoft.Maps.Pushpin) {
		            map.entities.removeAt(i);
		        }
		    }
			for(var pushPinIndex = 0; pushPinIndex < pushPins.length; pushPinIndex++){
				if(pushPins[pushPinIndex].location && pushPins[pushPinIndex].location[0] && pushPins[pushPinIndex].location[1]) {
					let location =  new Microsoft.Maps.Location(pushPins[pushPinIndex].location[0], pushPins[pushPinIndex].location[1]);
					let option = pushPins[pushPinIndex].option ? pushPins[pushPinIndex].option : null
					if(option && option.anchor && option.anchor[0] && option.anchor[1]){
						option.anchor = new Microsoft.Maps.Point(option.anchor[0], option.anchor[1])
					}
					let pushpin = new Microsoft.Maps.Pushpin(location, option);
					map.entities.push(pushpin);
					if(pushPins[pushPinIndex].addHandler){
						Microsoft.Maps.Events.addHandler(pushpin, pushPins[pushPinIndex].addHandler.type, 
							function (callback, data) { this.MakeCallback(callback, data) }.bind(this, pushPins[pushPinIndex].addHandler.callback, pushPins[pushPinIndex].addHandler.callbackData));
					}
				}
			}
		}
	}
	setInfoboxes(infoboxes, infoboxCreateType){
		if(map && infoboxes){
			for (var i = 0; infobox[infoboxCreateType] && i < infobox[infoboxCreateType].length ; i++) {
		        infobox[infoboxCreateType][i].setMap(null);
		    }
			infobox[infoboxCreateType] = [];
			if(infoboxes){
				for(var infoboxIndex = 0; infoboxIndex < infoboxes.length; infoboxIndex++){
					if(infoboxes[infoboxIndex].location && infoboxes[infoboxIndex].location[0] && infoboxes[infoboxIndex].location[1]) {
						let location =  new Microsoft.Maps.Location(infoboxes[infoboxIndex].location[0], infoboxes[infoboxIndex].location[1]);
						let option = infoboxes[infoboxIndex] ? infoboxes[infoboxIndex].option : null;
						if(option.htmlContent){
							option.htmlContent = ReactDOMServer.renderToStaticMarkup(option.htmlContent);
						}
						infobox[infoboxCreateType].push(new Microsoft.Maps.Infobox(location, option));
						infobox[infoboxCreateType][infoboxIndex].setMap(map);
						if(infoboxes[infoboxIndex].addHandler){
							Microsoft.Maps.Events.addHandler(infobox[infoboxCreateType][infoboxIndex], infoboxes[infoboxIndex].addHandler.type, 
								function (callback, data) { this.MakeCallback(callback, data) }.bind(this, infoboxes[infoboxIndex].addHandler.callback, infoboxes[infoboxIndex].addHandler.callbackData));
						}
					}
				}
			}
		}
	}
	setInfoboxesWithPushPins(infoboxesWithPushPins, infoboxCreateType){
		if(map && infoboxesWithPushPins){
			//Remove existing Infoboxes
			var i;
			for (i = 0; infobox[infoboxCreateType] && i < infobox[infoboxCreateType].length ; i++) {
		        infobox[infoboxCreateType][i].setMap(null);
		    }

		    //Remove existing Pushpins
		    for (i = map.entities.getLength() - 1; i >= 0; i--) {
		        var pushpin = map.entities.get(i);
		        if (pushpin instanceof Microsoft.Maps.Pushpin) {
		            map.entities.removeAt(i);
		        }
		    }

			infobox[infoboxCreateType] = [];

		    //Add Infoboxes with Pushpins
			if(infoboxesWithPushPins){
				for(var infoboxWithPushPinIndex = 0; infoboxWithPushPinIndex < infoboxesWithPushPins.length; infoboxWithPushPinIndex++){
					if(infoboxesWithPushPins[infoboxWithPushPinIndex].location){
						//Set Location
						let location =  new Microsoft.Maps.Location(infoboxesWithPushPins[infoboxWithPushPinIndex].location[0], infoboxesWithPushPins[infoboxWithPushPinIndex].location[1]);
						
						//Set Infobox Option
						let infoboxOption = infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxOption ? infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxOption : null
						
						//ConvertToHtml if Obj
						if(infoboxOption.htmlContent){
							infoboxOption.htmlContent = ReactDOMServer.renderToStaticMarkup(infoboxOption.htmlContent);
						}

						//If Handler added, initially hide Infobox
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler){
							infoboxOption["visible"] = false;
						}

						//Set Pushpin Option
						let pushPinOption = infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinOption ? infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinOption : null
						
						//Initilize if anchor for Pushpin
						if(pushPinOption.anchor && pushPinOption.anchor[0] && pushPinOption.anchor[1]){
							pushPinOption.anchor = new Microsoft.Maps.Point(pushPinOption.anchor[0], pushPinOption.anchor[1])
						}

					    //Set Infobox
						infobox[infoboxCreateType].push(new Microsoft.Maps.Infobox(location, infoboxOption));
						infobox[infoboxCreateType][infoboxWithPushPinIndex].setMap(map);

						//Set Infobox Callback if any
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler){
							Microsoft.Maps.Events.addHandler(infobox[infoboxCreateType][infoboxWithPushPinIndex], infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.type, 
								function (callback, data) { this.MakeCallback(callback, data) }.bind(this, infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.callback, infoboxesWithPushPins[infoboxWithPushPinIndex].infoboxAddHandler.callbackData));
						}		

						//Set Pushpin				
						let pushpin = new Microsoft.Maps.Pushpin(location, pushPinOption);
						map.entities.push(pushpin);

						//Set Pushpin Callback if any
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler){
							Microsoft.Maps.Events.addHandler(pushpin, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.type, 
								function (callback, data) { this.MakeCallback(callback, data) }.bind(this, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.callback, infoboxesWithPushPins[infoboxWithPushPinIndex].pushPinAddHandler.callbackData));
						}

						//Set InfoboxesWithPushPins handler if any
						if(infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler){
							this.setInfoboxesWithPushPinsHandler(infobox[infoboxCreateType][infoboxWithPushPinIndex], pushpin, infoboxesWithPushPins[infoboxWithPushPinIndex].addHandler);
						}
					}
				}
			}
		}
	}
	setGetLocation(getLocation){
		if(map && getLocation){
			if(getLocation.addHandler){
				Microsoft.Maps.Events.addHandler(map, getLocation.addHandler,
					function (callback, e) { 
						let point = new Microsoft.Maps.Point(e.getX(), e.getY());
  						let location = e.target.tryPixelToLocation(point);
						this.MakeCallback(callback, location);
					}.bind(this, getLocation.callback)
				);
			}
			else{
				Microsoft.Maps.Events.addHandler(map, "click",
									function (callback, e) { 
										let point = new Microsoft.Maps.Point(e.getX(), e.getY());
				  						let location = e.target.tryPixelToLocation(point);
										this.MakeCallback(callback, location);
									}.bind(this, getLocation.callback)
								);
			}
		}
	}
	setInfoboxesWithPushPinsHandler(infobox, pushpin, addHandler){
		if(addHandler === "mouseover"){
			Microsoft.Maps.Events.addHandler(pushpin, addHandler, function () {
			    infobox.setOptions({ visible: true });
			});
			Microsoft.Maps.Events.addHandler(pushpin, "mouseout", function () {
			    infobox.setOptions({ visible: false });
			});
		}
		else{
			Microsoft.Maps.Events.addHandler(pushpin, addHandler, function () {
			    infobox.setOptions({ visible: true });
			});
		}		
	}
	MakeCallback(callback, data){
		data ? callback(data) : callback();
	}
	createRegularPolygons(regularPolygons){
		if(map && regularPolygons){
			for (var i = map.entities.getLength() - 1; i >= 0; i--) {
		        var regularPolygon = map.entities.get(i);
		        if (regularPolygon instanceof Microsoft.Maps.Polygon) {
		            map.entities.removeAt(i);
		        }
		    }
		    for(let regularPolygonIndex = 0; regularPolygonIndex < regularPolygons.length; regularPolygonIndex++){
		    	if(regularPolygons[regularPolygonIndex].center && 
		    		regularPolygons[regularPolygonIndex].center[0] && 
		    		regularPolygons[regularPolygonIndex].center[1])
		    	{
		    		let location =  new Microsoft.Maps.Location(regularPolygons[regularPolygonIndex].center[0], regularPolygons[regularPolygonIndex].center[1]);
		    		let radius = regularPolygons[regularPolygonIndex].radius ? regularPolygons[regularPolygonIndex].radius : 0;
		    		let points = regularPolygons[regularPolygonIndex].points ? regularPolygons[regularPolygonIndex].points : 0;
		    		let option = regularPolygons[regularPolygonIndex].option ? regularPolygons[regularPolygonIndex].option : {};

		    		Microsoft.Maps.loadModule('Microsoft.Maps.SpatialMath', function () { 
					    var locations = Microsoft.Maps.SpatialMath.getRegularPolygon(location, radius, points, Microsoft.Maps.SpatialMath.DistanceUnits.Miles);
					    var polygon = new Microsoft.Maps.Polygon(locations, option);
					    map.entities.push(polygon);
					});
				}
		    }
		}
	}
	render() {
		return(
			<div className = { classSet('react-bingmaps', this.props.className) }>
			</div>
			);
	}
}

export default ReactBingmaps;

ReactBingmaps.propTypes = {
	bingmapKey: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	center: PropTypes.arrayOf(PropTypes.number),
	mapTypeId: PropTypes.string,
	navigationBarMode: PropTypes.string,
	supportedMapTypes: PropTypes.arrayOf(PropTypes.string),
	heading: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
	zoom: PropTypes.number,
	pushPins: PropTypes.arrayOf(
		PropTypes.shape({
		    location: PropTypes.arrayOf(PropTypes.number),
		    option: PropTypes.object,
		    addHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    })
		})
	),
	disableStreetside: PropTypes.bool,
	infoboxes: PropTypes.arrayOf(
		PropTypes.shape({
		    location: PropTypes.arrayOf(PropTypes.number),
		    option: PropTypes.object,
		    addHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    })
		})
	),
	infoboxesWithPushPins: PropTypes.arrayOf(
		PropTypes.shape({
			location: PropTypes.arrayOf(PropTypes.number),
			addHandler: PropTypes.string,
			infoboxOption: PropTypes.object,
			pushPinOption: PropTypes.object,
			infoboxAddHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    }),
		    pushPinAddHandler: PropTypes.shape({
		    	"type" : PropTypes.string,
		    	"callback" : PropTypes.func
		    })
		})
	),
	getLocation: PropTypes.object,
	regularPolygons: PropTypes.arrayOf(
		PropTypes.shape({
			center: PropTypes.arrayOf(PropTypes.number),
			radius: PropTypes.number,
			points: PropTypes.number,
			option: PropTypes.object
		})
	)
}
ReactBingmaps.defaultProps = {
	bingmapKey: undefined,
	center: undefined,
	mapTypeId: undefined,
	navigationBarMode: undefined,
	supportedMapTypes: undefined,
	heading: 0,
	pushPins: undefined,
	disableStreetside: true,
	infoboxes: undefined,
	infoboxesWithPushPins: undefined,
	zoom: undefined,
	getLocation: undefined,
	regularPolygons: undefined
}